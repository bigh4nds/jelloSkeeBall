import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;

import javax.vecmath.Point3f;
import javax.vecmath.Vector3f;



public class Physics {
	
	/**
	 * Updates the position of the given vertices based on the forces applied
	 * by the springs using the Runge Kutta 2nd order method.
	 * @param curr_verts The list of vertices.
	 * @param edge_adjacency The map containing the edges.
	 * @param external_force An external force that should be applied to all
	 * vertices, such as gravity.
	 */
	public static void computeRungeKutta(ArrayList<Vertex> object_verts, 
										HashMap<Integer, Edge> edge_adjacency,
										ArrayList<Vector3f> normals,
										ArrayList<Vertex> collision_verts,
										ArrayList<Integer> collision_faces,
										CollisionTree collision_tree,
										float collision_spring_constant,
										float cushion_amount,
										Vector3f external_force, 
										float time_interval) {

		
//		Set the collision status of each vertice.
		setCollisionStatus(object_verts, collision_verts, collision_faces, collision_tree, cushion_amount);
		
//		Compute the position and velocity of the first guess.
		ArrayList<Vector3f> initial_accelerations = computeAcceleration(object_verts, edge_adjacency, normals, collision_verts, collision_faces, collision_tree, collision_spring_constant, cushion_amount, external_force);
		
		ArrayList<Vertex> first_guess = copyVertices(object_verts);
		for (Vertex v : first_guess) {
			Point3f position = v.getPosition();
			Vector3f velocity = new Vector3f(v.getVelocity());
			velocity.scale(time_interval);
			
			position.add(velocity);
		}
		for (int i = 0; i < first_guess.size(); i++) {
			Vertex v = first_guess.get(i);
			Vector3f velocity = v.getVelocity();
			Vector3f acceleration = new Vector3f(initial_accelerations.get(i));
			acceleration.scale(time_interval);
			velocity.add(acceleration);
		}
		
		

//		Compute the accelerations at the first guess.
		ArrayList<Vector3f> first_guess_accelerations = computeAcceleration(first_guess, edge_adjacency, normals, collision_verts, collision_faces, collision_tree, collision_spring_constant, cushion_amount, external_force);
		
//		Compute the average of the accelerations deltas.
		ArrayList<Vector3f> average_accelerations = new ArrayList<Vector3f>();
		for (int i = 0; i < initial_accelerations.size(); i++) {
			Vector3f average_acceleration = new Vector3f(initial_accelerations.get(i));
			average_acceleration.add(first_guess_accelerations.get(i));
			average_acceleration.scale(.5f);
			average_accelerations.add(average_acceleration);
		}
		
//		Compute the new position of each vertex.
		for (int i = 0; i < object_verts.size(); i++) {
			Vertex v = object_verts.get(i);
			Vector3f velocity = v.getVelocity();
//			Vector3f acceleration = initial_accelerations.get(i);
			Vector3f acceleration = average_accelerations.get(i);
			acceleration.scale(time_interval);
			velocity.add(acceleration);
		}
		for (int i = 0; i < object_verts.size(); i++) {
			Vertex v = object_verts.get(i);
			Vector3f velocity = new Vector3f(v.getVelocity());
			Point3f position = v.getPosition();
			
//			Set the previous position of the vertex to be the current position.
			v.setPrevPosition(new Point3f(position));
			
			Vector3f k0 = new Vector3f(initial_accelerations.get(i));
			Vector3f k1 = new Vector3f(first_guess_accelerations.get(i));
			k0.scale(1f/2f);
			k1.scale(1f/2f);
			k0.add(k1);
			k0.scale(time_interval);
			velocity.add(k0);
			velocity.scale(time_interval);
			position.add(velocity);
		}		
	}
	
	/**
	 * Returns the force generated by the given edge.
	 * @param curr_verts
	 * @param edge
	 * @return
	 */
	private static float getSpringForce(Vertex v0, Vertex v1, Edge edge) {
		float cur_spring_length = v0.getPosition().distance(v1.getPosition());
		float spring_constant = edge.getSpringConstant();
		float equilibrium_length = edge.getEquilibriumLength();
		float length_delta = cur_spring_length - equilibrium_length;
		
		float total_spring_force = length_delta * spring_constant;
		
		return total_spring_force;
	}
	

	/**
	 * Computes the accelerations acting on each vertex due 
	 * to the springs, an external force, and any collisions.
	 * @param object_verts
	 * @param edge_adjacency
	 * @param normals
	 * @param collision_verts
	 * @param collision_faces
	 * @param collision_tree
	 * @param collision_spring_constant
	 * @param external_force
	 * @return
	 */
	private static ArrayList<Vector3f> computeAcceleration(ArrayList<Vertex> object_verts, 
										HashMap<Integer, Edge> edge_adjacency, 
										ArrayList<Vector3f> normals,
										ArrayList<Vertex> collision_verts,
										ArrayList<Integer> collision_faces,
										CollisionTree collision_tree,
										float collision_spring_constant,
										float cushion_amount,
										Vector3f external_force) {
		
		
//		Initialize the edges and make an empty ArrayList to hold the force applied
//		on each vertex.
		Collection<Edge> edges = edge_adjacency.values();
		ArrayList<Vector3f> forces = new ArrayList<Vector3f>();
		
//		Compute the force for each vertex after the external force
//		is applied.
		for (int i = 0; i < object_verts.size(); i++) {
			Vector3f external_force_temp = new Vector3f(external_force);
			forces.add(external_force_temp);
		}
		
//		Compute the force for each vertex after the forces from the
//		springs are applied.
		for (Edge edge : edges) {
			int v0_index = edge.getV0();
			int v1_index = edge.getV1();
			
			Vertex v0 = object_verts.get(v0_index);
			Vertex v1 = object_verts.get(v1_index);
			
			float total_spring_force = getSpringForce(v0, v1, edge);
			
//			Compute the direction vectors for the forces on the 2 vertices.
			Vector3f force_v0_direction = new Vector3f(v1.getPosition());
			force_v0_direction.sub(v0.getPosition());
			force_v0_direction.normalize();
			Vector3f force_v1_direction = new Vector3f(force_v0_direction);
			force_v1_direction.negate();
			
//			Compute the force vectors for the 2 vertices.
			Vector3f force_v0 = new Vector3f(force_v0_direction);
			force_v0.scale(total_spring_force/2);
			Vector3f force_v1 = new Vector3f(force_v1_direction);
			force_v1.scale(total_spring_force/2);

			Vector3f v0_cur_force = forces.get(v0_index);
			Vector3f v1_cur_force = forces.get(v1_index);
			v0_cur_force.add(force_v0);
			v1_cur_force.add(force_v1);
		}
		
		
//		Detect any collisions with the collision tree, and apply an elastic
//		force to the vertex if there is a collision.
		for (int i = 0; i < object_verts.size(); i++) {
			
			Vertex v = object_verts.get(i);
			Point3f position = new Point3f(v.getPosition());
			
//			If the collision plane is not null and the vertex is on the wrong side of the plane, compute the elastic force
//			on the vertex.
			for (Integer collision_face_index : v.getCollisionFaceIndices()) {
				Point3f p0 = collision_verts.get(collision_faces.get(collision_face_index)).getPosition();
				Point3f p1 = collision_verts.get(collision_faces.get(collision_face_index + 1)).getPosition();
				Point3f p2 = collision_verts.get(collision_faces.get(collision_face_index + 2)).getPosition();
				
				Plane collision_plane = new Plane(p0, p1, p2);
				
//				Move the origin closer to the plane. A hack to fix vertices "sliding" under
//				a mesh.
				Vector3f vector_to_move_closer_to_plane = new Vector3f(collision_plane.getNormal());
				vector_to_move_closer_to_plane.negate();
				vector_to_move_closer_to_plane.scale(cushion_amount);
				position.add(vector_to_move_closer_to_plane);
				
				
				float distance_to_collision_plane = collision_plane.getDistanceToPlane(position);
				float force_from_floor = distance_to_collision_plane * collision_spring_constant;
				
				Vector3f force_from_plane = collision_plane.getVectorToPlane(position);
				force_from_plane.normalize();
				force_from_plane.scale(force_from_floor);
				force_from_plane.negate();
				
				Vector3f cur_force = forces.get(i);
				cur_force.add(force_from_plane);
			}
		}
		
		
		
//		Compute the acceleration by dividing the force on a vertex by the mass
//		of the vertex.
		ArrayList<Vector3f> accelerations = forces;
		for (int i = 0; i < object_verts.size(); i++) {
			Vertex v = object_verts.get(i);
			Vector3f acceleration = accelerations.get(i);
			acceleration.scale(1/v.getMass());
		}
		
		return accelerations;
	}
	
	
	/**
	 * Check to see if which faces each jello vertex is colliding with.
	 * @param object_verts
	 * @param collision_verts
	 * @param collision_faces
	 * @param collision_tree
	 */
	private static void setCollisionStatus(ArrayList<Vertex> object_verts, 
										ArrayList<Vertex> collision_verts,
										ArrayList<Integer> collision_faces,
										CollisionTree collision_tree,
										float cushion_amount) {
		
		for (Vertex v : object_verts) {
			Point3f position = v.getPosition();
			Point3f prev_position = v.getPrevPosition();
	
//			If the vertex is already colliding with a face apply the force from
//			the plane it is colliding with.

//			Copy the colliding face indices for the vertex and clear the colliding face indices for the vertex.
			ArrayList<Integer> collision_face_indices = new ArrayList<Integer>();
			for (Integer collision_face_index : v.getCollisionFaceIndices()) {
				collision_face_indices.add(collision_face_index);
			}
			v.setCollisionFaceIndices(new ArrayList<Integer>());
			
//			Check to see if the vertex is still colliding with the faces.
			for (Integer collision_face_index : collision_face_indices) {
				
				Point3f p0 = collision_verts.get(collision_faces.get(collision_face_index)).getPosition();
				Point3f p1 = collision_verts.get(collision_faces.get(collision_face_index + 1)).getPosition();
				Point3f p2 = collision_verts.get(collision_faces.get(collision_face_index + 2)).getPosition();
				
				Plane collision_plane = new Plane(p0, p1, p2);
				
//				Move the origin closer to the plane. A hack to fix vertices "sliding" under
//				a mesh.
				Vector3f vector_to_move_closer_to_plane = new Vector3f(collision_plane.getNormal());
				vector_to_move_closer_to_plane.negate();
				vector_to_move_closer_to_plane.scale(cushion_amount);
				Vector3f origin = new Vector3f(position);
				origin.add(vector_to_move_closer_to_plane);

				boolean still_colliding = CollisionTree.hit(origin, collision_plane.getNormal(), p0, p1, p2, 0f, 9999f);


//				RE-add the face to the faces the vertex is colliding with.
				if (still_colliding) {
					v.getCollisionFaceIndices().add(collision_face_index);
				}
			}
	
			
//			Detect any new faces the vertex is colliding with by using the collision tree.
			ArrayList<Integer> new_collision_face_indices = collision_tree.detectCollision(collision_verts, collision_faces, prev_position, position, cushion_amount);
			
			for (Integer new_collision_face_index : new_collision_face_indices) {
				if (!v.getCollisionFaceIndices().contains(new_collision_face_index)) {
					v.getCollisionFaceIndices().add(new_collision_face_index);
				}
			}
		}
	}
	
	private static ArrayList<Vertex> copyVertices(ArrayList<Vertex> verts) {
		ArrayList<Vertex> new_verts = new ArrayList<Vertex>();
		for (Vertex v : verts) {
			Vector3f vel = new Vector3f(v.getVelocity());
			Point3f pos = new Point3f(v.getPosition());
			float mass = v.getMass();
			
			Vertex new_v = new Vertex(pos, mass, vel);
			new_verts.add(new_v);
		}
		
		return new_verts;
	}
}